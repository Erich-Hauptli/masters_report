\section{Career Paths}
\label{sect:career-paths}
The goal of the career paths module is to generate data, such that a web user
interface could generate a nodal mapping of the career paths taken to reach the
specified career goal.  The node transitions along with the transition
frequencies are returned to the user interface as JSON Objects.  Additionally,
the node ordering and information about each individual node is also returned in
a JSON Object.  This information can then be used to generate a nodal map
depicting various ways of achieving a career goal.  

An example is depicted in figure \ref{fig:nodal map}, which shows various
interconnected nodes that eventually arrive at the goal node, J.  Currently,
each node is labeled with a letter from the alphabet, but ProGENitor would
replace these with actual node names, such as a job title or an educational
degree. The nodes are arranged such that the user most likely travels from left
to right, but the occasional infrequently traveled transition may flow in the
reverse direction.  The frequency that the the path is traveled is depicted
through color in this example.  Red depicts the most frequently traveled path,
then blue, green, and finally the least traveled path is colored black.  Each
node would then be able to display the individual node information upon user
request; either through clicking on the node or through some other user action. 
Note, that ProGENitor does not limit the method in which the user interface is
displayed; it simply passes back statistical information about the nodes, the
transitions between each node, and the individual data about each node.  It is
up to the web user interface developer to determine how the end product is rendered.


\usetikzlibrary{shapes,arrows,chains}

\begin{figure}[H]
	\centering
  
% Start the picture
\begin{tikzpicture}[%
    >=triangle 60,              % Nice arrows; your taste may be different
    start chain=going below,    % General flow is top-to-bottom
    node distance=3mm and 20mm, % Global setup of box spacing
    every join/.style={norm},   % Default linetype for connecting boxes
    ]
% ------------------------------------------------- 
% A few box styles 
% <on chain> *and* <on grid> reduce the need for manual relative
% positioning of nodes
\tikzset{
  base/.style={draw, on chain, on grid, align=center, minimum height=2ex},
  node/.style={base, circle, text width=3em},
  % Connector line styles for different parts of the diagram
  norm/.style={->, draw},
  thin/.style={->,>=stealth',shorten >=1pt, black},
  nm/.style={->,>=stealth',shorten >=1pt, green},
  to/.style={->,>=stealth',shorten >=1pt,semithick,blue},
  thick/.style={->,shorten >=1pt,very thick, red},
  it/.style={font={\small\itshape}}
}
% -------------------------------------------------
% Start by placing the nodes
\node [node] (a) {A};
% Use join to connect a node to the previous one 
\node [node, right = of a] (b) {B};
\node [node, above = of b, yshift=25mm] (c) {C}; 
\node [node, below of = b, yshift=-25mm](d) {D};
\node [node, right=of d, yshift =15mm](e) {E};
\node [node, right=of c, yshift=-15mm](f) {F};
\node [node, right=of f, yshift=-15mm](g) {G};
\node [node, right=of f, yshift=15mm](h) {H};
\node [node, right=of f, yshift=-40mm](i) {I};
\node [node, right=of g](j) {J};

\draw[thick] (a) to (b);
\draw[thick] (a) to[bend left=30] (c);
\draw[nm] (a) to[bend right=30] (d);
\draw[nm] (d) to (e); 
\draw[thin] (a) to[bend right=30] (e);
\draw[nm] (c) to (e);
\draw[to] (c) to (f);
\draw[thin] (e) to (b);
\draw[to] (e) to (g);
\draw[to] (f) to (g);
\draw[thick] (b) to (g);
\draw[thin] (f) to (h);
\draw[thin] (e) to (i);
\draw[thick] (g) to (j);
\draw[thin] (h) to (j);
\draw[thin] (i) to (j);

% -------------------------------------------------
\end{tikzpicture}

	\caption{Career Path Nodal Map}
	\label{fig:nodal map}
\end{figure}

\subsection{Node Interconnects}
The node interconnect portion of code finds all of the nodes that
users pass through and the order at which they pass through them.  It then
tallies the number of times all of the users pass along each transition
path to allow for the career map to depict not only the point to point
connections, but also how frequently that path is traveled.  The high level
process to generate this node interconnection data is depicted in figure
\ref{fig:node interconnect} below.


\usetikzlibrary{shapes,arrows,chains}

\begin{figure}[H]
	\centering
% Start the picture
\begin{tikzpicture}[%
    >=triangle 60,              % Nice arrows; your taste may be different
    start chain=going below,    % General flow is top-to-bottom
    node distance=6mm and 60mm, % Global setup of box spacing
    every join/.style={norm},   % Default linetype for connecting boxes
    ]
% ------------------------------------------------- 
% A few box styles 
% <on chain> *and* <on grid> reduce the need for manual relative
% positioning of nodes
\tikzset{
  base/.style={draw, on chain, on grid, align=center, minimum height=4ex},
  proc/.style={base, rectangle, text width=8em},
  test/.style={base, diamond, aspect=2, text width=5em},
  % Connector line styles for different parts of the diagram
  norm/.style={->, draw},
  it/.style={font={\small\itshape}}
}
% -------------------------------------------------
% Start by placing the nodes
\node [proc] (p0) {Pull all\newline relevant data};
% Use join to connect a node to the previous one 
\node [test, join] (t1) {IF transition is new, add to storage array};
\node [test, join] (t2) {ELSE increment counter for transition in storage
array}; 
\node [proc, join](p1) {Generate return JSON and ArrayList};

\draw [->, dotted, thick, shorten >=1mm]
  (t2.south) -- ++(50mm,-3mm)  -- ++(27mm,0) 
  |- node [black, near end, yshift=0.75em, it]
    {For each node transition} (t1);

% -------------------------------------------------
\end{tikzpicture}
	\caption{High Level Node Interconnect Generation}
	\label{fig:node interconnect}
\end{figure}

The process in defining and counting these interconnects was coded in Java in
the find edges method of the connections package.  The process flow is listed
in detail below:

\begin{description}
    \item[Node Interconnect Generation:]
\end{description}
\begin{enumerate}
  \item For each ID passed to Interconnect Generation Module:
  \begin{enumerate}
    \item Pull Job Data and add it to the Nodes Array List.
    \item Pull Education Data and add it to the Nodes Array List.
    \item Set Min equal to MAX Integer and Max equal to MIN Integer.
    \item For each element of the Nodes ArrayList:
    \begin{enumerate}
      \item If date of data for element of Nodes is less than Min and more than
      Max, store the data and set Min equal to date of data.
      \item After all elements of Nodes ArrayList considered, Add stored data
      to User ArrayList and set Max equal to Min.
  	\end{enumerate}
  	\item For each element of User ArrayList:
  	\begin{enumerate}
  	  \item If A is NULL, set A equal to User element node name.
  	  \item Else set B equal to A and set A equal to User element node name.
  	  \item If Connects ArrayList is empty, add B,A,1 to Connects ArrayList.
  	  \item Else check if B,A exists in the Connects ArrayList:
  	  \begin{enumerate}
  	    \item If it exists, increment the counter of the row.
  	    \item If it does not exist, add B,A,1 to the Connects ArrayList.
  	  \end{enumerate}
  	\end{enumerate}
  \end{enumerate}
  \item Push Connects ArrayList containing all node transitions and transition
  counts to a JSON Object containing a JSON Array.
  \item Return both the ArrayList and the JSON Object.
\end{enumerate}

\subsection{Node Ordering}
The node ordering portion of code sorts the nodes such that the major
transitions flow in order from start to finish. It does this so that the flow
of transitions can be mapped in a manner that is not overly confusing.  Figure
\ref{fig:node ordering} shows the high level process that the code follows
to generate the node groupings.  These groupings can then be fed to the end user
interface to order the nodes in a fashion that shows the typical flow of careers
that reach the destination goal.

\usetikzlibrary{shapes,arrows,chains}

\begin{figure}[H]
	\centering
% Start the picture
\begin{tikzpicture}[%
    >=triangle 60,              % Nice arrows; your taste may be different
    start chain=going below,    % General flow is top-to-bottom
    node distance=6mm and 60mm, % Global setup of box spacing
    every join/.style={norm},   % Default linetype for connecting boxes
    ]
% ------------------------------------------------- 
% A few box styles 
% <on chain> *and* <on grid> reduce the need for manual relative
% positioning of nodes
\tikzset{
  base/.style={draw, on chain, on grid, align=center, minimum height=4ex},
  proc/.style={base, rectangle, text width=8em},
  test/.style={base, diamond, aspect=2, text width=5em},
  % Connector line styles for different parts of the diagram
  norm/.style={->, draw},
  it/.style={font={\small\itshape}}
}
% -------------------------------------------------
% Start by placing the nodes
\node [proc] (p0) {Generate HashSet of all nodes};
% Use join to connect a node to the previous one 
\node [test, join] (p1) {Find worst input and output transition};
\node [proc, join] (p2) {Store worst transition edges};
\node [proc, join] (p3) {Identify Starting Nodes}; 
\node [test, join] (p4) {Group Nodes based on prior connections};
\node [proc, join] (p5) {Store node Grouping in ArrayList};
\node [proc, join] (p6) {Return Node Ordering as JSON Object and ArrayList};

\draw [->, dotted, thick, shorten >=1mm]
  (p2.south) -- ++(40mm,-3mm)  -- ++(27mm,0) 
  |- node [black, near end, yshift=0.75em, it]
    {For Each Node} (p1);
\draw [->, dotted, thick, shorten >=1mm]
  (p5.south) -- ++(40mm,-3mm)  -- ++(27mm,0) 
  |- node [black, near end, yshift=0.75em, it]
    {For Remaining Nodes} (p4);

% -------------------------------------------------
\end{tikzpicture}
	\caption{High Level Node Order Generation}
	\label{fig:node ordering}
\end{figure}

The process in defining the node ordering for the nodes was coded in Java in the
find node order method of the connections package.  The process flow is listed
in detail below:

\begin{description}
    \item[Node Ordering Generation:]
\end{description}
 \begin{enumerate}
   \item Generate HashSet of All Nodes
   \item For each Node in HashSet:
   \begin{enumerate}
     \item Initialize transitional weight to 0.
     \item For each element of the Node Interconnect Array List:
     \begin{enumerate}
       \item Check if Node matches the input node.
       \item Check if the number of transitions to the node is greater than the
       transitional weight.
       \item If both checks are true; set the transitional weight to the current
       Array List line's number of transitions.
       \item Also, if both checks are true; store this Array List line.
     \end{enumerate}
     \item After the worst input transition is found for the node, store it in
     the Heavy Edges HashSet.
     \item Repeat this entire step for the output nodes.
   \end{enumerate}
   \item For each Heavy Edge element, search the Node Interconnect Array List
   for input nodes that are also destination nodes.
   \begin{enumerate}
     \item Any nodes not found are set as start nodes.
     \item Repeat this step for output nodes that are also starting nodes.  Any
     nodes not found are set as ending nodes.
   \end{enumerate}
   \item Add all the starting nodes to node 0 and add them to the Node Store
   HashSet.
   \item Add all nodes that are not starting nodes to the Remaining Nodes
   HashSet.
   \item Increment the group number to 1.
   \item Until the Remaining Nodes HashSet is empty, loop through the following
   steps.
   \begin{enumerate}
     \item For each Node in Node Store, store all destination nodes in a HashSet
     that Node in Node Store transitions to.
     \item For each destination node stored in the previous step, find all
     possible next destination nodes and check if they are contained within the
     HashSet generated in the previous step.
     \begin{enumerate}
       \item If one is contained within the previously generated HashSet, remove
       the node from the HashSet.
     \end{enumerate}
     \item Add remaining nodes to next node grouping.  Also remove remaining
     nodes from Remaining Nodes HashSet.
     \item Add the node group to the NodeReturn ArrayList.
     \item Increment the group number.
     \item Replace the nodes in the Starting Nodes hash set with the nodes that
     were just added to a group.
   \end{enumerate} 
   \item Generate a JSON Object containing a JSON Array the node groupings from
   the NodeReturn ArrayList.
   \item Return both the JSON Object and the NodeReturn ArrayList.
 \end{enumerate}



\subsection{Node Details}
Presenting all of the potential information would overwhelm any user interface,
so instead many of the details are buried within each node and can be queried
by the end user, by selecting the node of interest.  As each node contains
additional details such as the place of employment or education, time spent at
the school or job, or any other node relevant pieces of information; the data
must be gathered upon user request, as to not slow down the overall map
generation.  Once the request is made, the data about the individuals who
reached the goal node and the data about all of the users who passed through a
particular node are pulled.  This data is then broken down into a statistic for
both cases and compared against each other to determine if something occurred
more frequently for the users who reached the goal node versus those who had
not.  This way any significant differences could be raised to the end user's
attention as potentially important steps to reaching the final goal.  The high
level process to generating this data is depicted in figure \ref{fig:node
details} below.

\usetikzlibrary{shapes,arrows,chains}

\begin{figure}[H]
	\centering
% Start the picture
\begin{tikzpicture}[%
    >=triangle 60,              % Nice arrows; your taste may be different
    start chain=going below,    % General flow is top-to-bottom
    node distance=6mm and 60mm, % Global setup of box spacing
    every join/.style={norm},   % Default linetype for connecting boxes
    ]
% ------------------------------------------------- 
% A few box styles 
% <on chain> *and* <on grid> reduce the need for manual relative
% positioning of nodes
\tikzset{
  base/.style={draw, on chain, on grid, align=center, minimum height=4ex},
  proc/.style={base, rectangle, text width=10em},
  test/.style={base, diamond, aspect=2, text width=8em},
  % Connector line styles for different parts of the diagram
  norm/.style={->, draw},
  it/.style={font={\small\itshape}}
}
% -------------------------------------------------
% Start by placing the nodes
\node [proc] (p0) {Pull relevant and All Node Data};
% Use join to connect a node to the previous one 
\node [proc, join] (p1) {Count occurrences of each data instance};
\node [proc, join] (p2) {Calculate percentage of occurrence for each
instance};
 \node [proc, join] (p3) {Compare each relevant data occurrence to each all data
 occurance};
 \node [test, join] (t0) {IF relevant is more than five percent greater than
 all};
 \node [proc, join] (p4) {Flag relevant data occurrence as significant};
 \node [proc, join] (p5) {Return JSON Object and ArrayList containing
 relative percentage node data};

\draw [->, dotted, thick, shorten >=1mm]
  (p2.south) -- ++(50mm,-3mm)  -- ++(27mm,0) 
  |- node [black, near end, yshift=0.75em, it]
    {For each data column} (p1);
\draw [->, dotted, thick, shorten >=1mm]
  (p4.south) -- ++(50mm,-3mm)  -- ++(27mm,0) 
  |- node [black, near end, yshift=0.75em, it]
    {For each data occurrence} (p3);

% -------------------------------------------------
\end{tikzpicture}
	\caption{High Level Node Detail Generation}
	\label{fig:node details}
\end{figure}
\pagebreak

The process in defining the details and significant details for each node was
coded in Java in the find node info method of the connections package.  The
process flow is listed in detail below:

\begin{description}
    \item[Node Detail Generation:]
\end{description}
\begin{enumerate}
  \item Pull in Profile ArrayList, tag each element as a profile, and then add
  the element to the Complete ArrayList.
  \item Repeat this for the Jobs ArrayList and the Education ArrayList.
  \item Check each element of the Complete ArrayList.
  \begin{enumerate}
    \item If the element contains the node that details are being pulled on, add
    the element to the Relevant ArrayList.
  \end{enumerate}
  \item Pull the headers associated with the node that details are being pulled
  from.
  \item Pull all the data in the database for that node and store in the All
  Node Data ArrayList.
  \item For each element of the Complete ArrayList:
  \begin{enumerate}
    \item Split the element into columns and step through each column.
    \begin{enumerate}
    	\item Check if the column element is a start or end year and instead
    	calculate the years spent at the node.
    	\begin{enumerate}
    	  \item If the end year is set to current, find the current year and then
    	  calculate the total years spent at the node.
    	\end{enumerate}
    	\item Add the column value to a HashSet to obtain all possible values for
    	the column.
    	\item Step through the column counting each value instance to obtain a
    	count for each different value.
    	\item Calculate the percentage for each value in the column by diving the
    	count by the total number of elements.
    	\item Push these values into the Relevant ArrayList.
    \end{enumerate} 
  \end{enumerate}
  \item Repeat for each element of the All Node Data Array List
  \item Compare the percentages for each element of the Relevant ArrayList to
  the percentages from the All Node Data Array List.
  \begin{enumerate}
    \item Flag the column value for any instance where the Relevant value's
    percentage exceeds the percentage for all the data by 5\%.
    \item Return this value as relevant so that it can be identified to the user
    as significant to the node.
  \end{enumerate}
  \item Return the Relevant ArrayList and a JSON Object containing a JSON Array
  of the same data.
\end{enumerate}

