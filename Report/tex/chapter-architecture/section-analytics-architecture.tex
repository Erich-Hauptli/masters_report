\section{Career Path Architecture}
Once the databases are established and loaded, the real work can begin. 
ProGENitor takes in a request query and then using the career path modules,
graphs out the similar career paths taken by others who traversed through the
query point.  ProGENitor uses basic graph theory~\cite{graph_theory} where it
treats all significant events as vertices and all of the transitions between
these events as edges.  It also provides details about what was special about
these individuals, as they went through each vertex of their lives.  Then,
through Weka, the code draws out the complex events that had the largest impact
towards the the users passing through the query point.  One advantage to using
graph theory to present the results is that most of the end customers for
ProGENitor will be very familiar with this type of data.  As many of these
customers will be social sites, which essentially operate off of graph theory as
well~\cite{social_datasets}, the end users should be well accustom to the
results and potentially may already have a method to render the data.

As depicted in Figure~\ref{fig:analytics_block}, the
code is broken into four pieces.  One piece gathers all of the vertices and
defines the important edges between the vertices.  Another piece of the code
looks at the many different edges and attempts to order the vertices in a manner
that they can be graphed from left to right without a lot of confusing edge
crossings.  A third piece of code draws out the data about each vertex and
identifies the significant pieces of information that separate the users in the
query from everyone else who passed through the vertex.  Finally, the last piece
of code, uses Weka to draw out the complex action or actions that had the
greatest significance in causing the users to pass through the query point.

\begin{figure}[H]
	\setlength{\unitlength}{0.1in} % selecting unit length
	\centering % used for centering Figure
	\begin{picture}(40,26) % picture environment with the size (dimensions)
		% 32 length units wide, and 15 units high.
		\put(-7,12.5) {User Query}
		\put(2.5,13){\vector(1,0){2}}
		\put(5,10.5){\framebox(12,5){Data Collection}}
		\put(17,12.5){\vector(1,-3){3}}
		\put(17,12.5){\vector(2,-1){4}}
		\put(17,12.5){\vector(2,1){4}}
		\put(17,12.5){\vector(1,3){3}}
		\put(21,21){\framebox(14,5){Edges}}
		\put(21,14){\framebox(14,5){Vertex Ordering}}
		\put(21,7){\framebox(14,5){Vertex Details}}
		\put(21,0){\framebox(14,5){Weka}}
		\put(35,23.5){\vector(2,-3){6}}
		\put(35,16.5){\vector(2,-1){4}}
		\put(35,9.5){\vector(2,1){4}}
		\put(35,2.5){\vector(2,3){6}}
		\put(37,12.5) {Results}
	\end{picture}
	\caption{Career Path Block Diagram} % title of the Figure
	\label{fig:analytics_block} % label to refer figure in text
\end{figure}
\subsection{Career Path Technology Stack}
As detailed in Chapter~\ref{chap:introduction}, the code is written in Java.  As
the code for the graphing can only show users paths taken and important pieces of data along the
way, Weka code was added to also derive insights based on combinations of data. 
Machine learning based on data can be very math intensive and complex.  There
are many different ways of looking at data sets.  To simplify this, the Weka
tool set was used in this project.  The tool set has many different algorithms
that can be easily implemented and applied.  In the case of ProGENitor, Weka has
only been applied to the education data; however, it could easily be
expanded to analyze additional data, such as the data about jobs.  Weka was
chosen as it has a well designed Java API and is open source.  One good
alternative that could have been used in place of Weka is RapidMiner.  Weka was
chosen for the implementation as there is significant documentation surrounding
both tool sets and RapidMiner's largest advantage, the graphical interface, is
not applicable.
