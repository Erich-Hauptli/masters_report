\section{Career Path Results}
\label{sect:career-path-results}
Examples of the JSON objects returned by the career mapping portion of the
ProGENitor code are shown below.  Each example does not contain a complete set
of data as that would be too much to show in this report.

\subsection{Node Interconnect JSON Results}
In the node interconnect JSON Object, an array of node interconnections is
returned.  Each element of the array contains a starting node and an ending node
for the transition.  Additionally, the array element also contains a transition
frequency.  The transition frequency indicates how often the transition occurs. 
Currently this is on a scale of 0-10, so that user data is not exposed to the
ProGENitor users.  Thus, the actual number of users transitioning from one node
to another node is divided by the total number of users that data was pulled for
the career map.  This percentage is then multiplied by 10 and rounded.

\noindent\{"Node Connections":\\*
\{"node A":"Bachelors","node B":"Masters","transition frequency":6\},\\*
\{"node A":"Masters","node 	B":"Circuit Designer","transition frequency":7\},\\*
\{"node A":"Circuit Designer","node B":"Block 	Owner","transition
frequency":8\},\\* \{"node A":"Block Owner","node B":"Design Owner","transition
frequency":9\},\\*
\ldots\\* 
\{"node A":"Coder","node B":"Function Lead","transition frequency":0\},\\*
\{"node A":"Function Lead","node B":"Masters","transition frequency":0\}]\},\\*


\subsection{Node Ordering JSON Results}
In the node ordering JSON Object, an array containing the order which the nodes
should be display is returned.  Each element of the array contains a node name
and the order number it should be displayed.  Thus, the nodes with an order of
1 should be the first nodes displayed in the career path map, then
moving sequentially up, each node in the group should be displayed until the
final node group is displayed.  This will allow the map to flow with minimum
interconnects flowing in the reverse order.

\noindent \{"Node Ordering":\\*
	\indent\{"node	name":"Timing","order":"2"\},\\*
	\indent\{"node name":"Signal Integrity","order":"2"\},\\*
	\indent\{"node name":"Platform Chief Engineer","order":"7"\},\\*
	\indent\{"node name":"PHD","order":"5"\},\\*
	\indent\{"node name":"Entry Coder","order":"1"\},\\*
	\indent\ldots\\*
	\indent\{"node name":"Block Owner","order":"6"\},\\*
	\indent\{"node name":"Chiplet Designer","order":"1"\}]\},\\*


\subsection{Node Details JSON Results}
In the node detail JSON Object, an Array containing all of the various nodes
will be returned.  Each node will be nested object containing an array of data
points.  Examples of these data points are titles, companies, time spent at the
node, and any other points of interest within the database.  Each of these data
points will be an Object that also contains a nested JSON array.  This array
will then contain data about each data point, broken down into the percentage of
users who matched a specific piece of information for that data point.  For
example, shown below is a data point for the companies that users worked for
when they worked at a Timing job.  To protect user data, this is not shown as
number of users, but as the percentage of users who spent time working for one
company versus all users who spent time working at that particular job.  To
avoid having millions of entries, a threshold is set such that if the threshold
is not met, the data is lumped into an Other group.  This Other group would then
contain the total user data that did not meet the threshold.  Finally, a JSON
Object containing any significant data points is also returned.  ProGENitor
compares the users who reached the goal against all users who passed through the
node to determine what was statistically different from the users who reached
the target goal.  These differences are listed in the significant data object.

\noindent \{"Nodes Data":\\*
	\indent \{"Node Name":"Timing","Node Data":\\*
		\indent \{"Data Breakout":\\*
		\indent \indent	\{"name":"Other","value":"0.9174312\%"\}\\*
		\indent	\indent \{"name":"Timing\_all","value":"100.0\%"\},\\*
		\indent	"Data Point Name":"title"\},\\*
		\indent\{"Data Breakout":\\*
		\indent	\indent	\{"name":"Verizon","value":"100.0\%"\},\\*
		\indent	\indent	\{"name":"Verizon\_all","value":"11.33721\%"\},\\*
		\indent	\indent	\{"name":"Cisco Systems\_all","value":"12.790698\%"\},\\*
		\indent	\indent	\{"name":"Boeing\_all","value":"7.5581393\%"\},\\*
		\indent	\indent	\{"name":"Hewlit-Packard\_all","value":"8.139535\%"\},\\*
		\indent	\indent	\{"name":"IBM\_all","value":"7.2674417\%"\},\\*
		
		\indent	\indent	\{"name":"General Motors\_all","value":"8.72093\%"\},\\*
		\indent	\indent	\{"name":"General Electric\_all","value":"7.2674417\%"\},\\*
		\indent	\indent	\{"name":"Microsoft\_all","value":"8.72093\%"\},\\*
		\indent	\indent	\{"name":"Intel\_all","value":"8.72093\%"\},\\*
		\indent	\indent	\{"name":"Lockheed Martin\_all","value":"11.046512\%"\},\\*
		\indent	\indent	\{"name":"AT\&T\_all","value":"8.430233\%"\},\\*
		\indent"Data Point Name":"company"\},\\*
		\indent\ldots\\*
		\indent \{"Significant":\}\},\\*

\subsection{Example Carrer Maps}

\usetikzlibrary{shapes,arrows,chains}

\begin{figure}[H]
	\centering
  
% Start the picture
\begin{tikzpicture}[%
    >=triangle 60,              % Nice arrows; your taste may be different
    start chain=going below,    % General flow is top-to-bottom
    node distance=3mm and 28mm, % Global setup of box spacing
    every join/.style={norm},   % Default linetype for connecting boxes
    ]
% ------------------------------------------------- 
% A few box styles 
% <on chain> *and* <on grid> reduce the need for manual relative
% positioning of nodes
\tikzset{
  base/.style={draw, on chain, on grid, align=center, minimum height=2ex},
  node/.style={base, circle, text width=5em},
  % Connector line styles for different parts of the diagram
  norm/.style={->, draw},
  thin/.style={->,>=stealth',shorten >=1pt, black},
  nm/.style={->,>=stealth',shorten >=1pt, green},
  to/.style={->,>=stealth',shorten >=1pt,semithick,blue},
  thick/.style={->,shorten >=1pt,very thick, red},
  it/.style={font={\small\itshape}}
}
% -------------------------------------------------
% Start by placing the nodes
\node [node, densely dotted, it] (a) {Bachelors};
% Use join to connect a node to the previous one 
\node [node, right = of a, yshift=20mm] (b) {Masters};
\node [node, right = of a, yshift=-20mm] (c) {Draftsman}; 
\node [node, right = of b](d) {PHD};
\node [node, right = of c](e) {Architect};
\node [node, right = of e, yshift=20mm](f) {Lead Architect};
\node [node, right = of f](g) {Partner};

\draw [to] (a) to (c);%Bachelors,Draftsman,4
\draw [thin] (c) to (b);	%Draftsman,Masters,1
\draw[thick] (b) to (e);	%Masters,Architect,7
\draw[thick] (e) to (f);	%Architect,Lead Architect,7
\draw[thick] (f) to (g);	%Lead Architect,Partner,7
\draw[to] (a) to (b);	%Bachelors,Masters,5
\draw[thin] (b) to (d); %Masters,PHD,0
\draw[thin] (d) to (f);	%PHD,Lead Architect,0
\draw[nm] (c) to (e);	%Draftsman,Architect,2
\draw[thin] (e) to [bend left=20] (b);	%Architect,Masters,0
\draw[thin] (f) to [bend left=20] (b);	%Lead
% Architect,Masters,0

% -------------------------------------------------
\end{tikzpicture}

	\caption{Career Path Nodal Map}
	\label{fig:nodal map}
\end{figure}



\subsection{Career Path Performance}
All of the work on this project has been done on a personal laptop with an 8
core i7 2.70GHz processor, a 500GB 7200 RPM 32MB Cache SATA 6.0Gb/s hard drive,
and 16GB of DDR3 Memory.  As ProGENitor would be run on a server instead of a
personal laptop, it can be expected that the performance for all workloads would
be improved.  Still, the overall application run time would be impacted by both
the number of users within the database and the total access times to the
database itself.  As the database was on a local drive, the access times were
much less in these run times than they could be with a remote database.  

For generating the career path map, 10 cases were run, as shown below in table
\ref{table:career performance}.  These 10 cases generate a range of matched
users, total users, and number of nodes returned.  By doing this, a ruff estimate as to how
long a query to ProGENitor might take can be ascertained.  As seen in table
\ref{table:career performance}, an average query would take about 2.5 seconds,
but might take much longer depending on the number of users in the database and the number that
match the query.  One thing to note about the data in these tables is that there
is currently a bug in the ProGENitor code that forced a cap of 500 matched
users.  Any number of matched users returned beyond that 500 is currently
ignored.  This does not invalidate the data and may be something that is deisred
simply to improve overall performance.  In the future this issue would be
resolved, but for now, please note this limiting factor when looking over the
data in the following tables.

\begin{table}[H]
  \centering
  \begin{tabular}{|p{17mm}|p{16mm}|p{10mm}|p{18mm}|p{19mm}|p{20mm}|p{14mm}|}
  \hline
  \
  %heading
  Case&Matched Users&Total Users&Data\newline Collection&Edge\newline
  Generation&Order Generation&Total\\
  \hline\hline
  Platform Chief&109&5000&708.9ms&341.4ms&74.4ms&1.12s\\ \hline
  Civil\newline Degree&2684&5000&2.28s&2.37s&6.3ms&4.65s\\ \hline 
  Architect&2330&5000&2.27s&2.19s&5.7ms&4.47s\\ \hline
  Circuit Designer&675&5000&2.23s&1.0s&68.5ms&3.3s\\ \hline
  Worked For IBM&260&5000&1.31s&457.5ms&85.6ms&1.85s\\ \hline
  Fission Degree&260&5000&1.31s&407.6ms&6.3ms&1.73s\\ \hline
  Analog Degree&24&5000&361.2ms&66.8ms&43.1ms&471.3ms\\ \hline
  Embedded&55&5000&466.8ms&269.5ms&94.7ms&831.1ms\\ \hline
  Floor- \newline planning&49&5000&441.5ms&106.5ms&103.3ms&651.5ms\\ \hline
  Circuit Designer&1401&10000&4.27s&1.72s&70.8ms&6.06s\\ \hline
  \hline\hline
  Minimum&24&5000&361.2ms&66.8ms&5.7ms&471.3ms\\ \hline
  Maximum&2684&10000&4.27s&2.37s&103.3ms&6.06s\\ \hline
  Average&785&550&1.55s&893ms&55.9ms&2.5s\\ \hline
  \end{tabular}
  \label{table:career performance}
  \caption{Career Path Generation Time}
\end{table}

As seen in table \ref{table:career performance}, the bulk of the time that
ProGENitor runs is spent in querying the database and pulling in the data to be
processed.  Then generating the node interconnects takes up about a third of the
run time. Lastly, determining the order in which to display the nodes runs in
about 1 to 2\% of the overall runtime.  Thus, to improve or maintain performance most of
the focus needs to be on the database pull.  This is not an uncommon problem and
many people spend careers working on this problem.  ProGENitor assumes that
whoever deploys the tool would either have a smaller database or a database
expert who could help refine the database accesses.

\begin{table}[H]
  \centering
  \begin{tabular}{|p{17mm}|p{16mm}|p{10mm}|p{18mm}|p{19mm}|p{20mm}|}
  \hline
  \
  %heading
  Case&Matched Users&Total Users&Total Nodes&All Nodes&Average Node\\
  \hline\hline
  Platform Chief&109&5000&23&4.7s&204.4ms\\ \hline
  Civil\newline Degree&2684&5000&7&6.34s&906.3ms\\ \hline 
  Architect&2330&5000&6&6.15s&1.02s\\ \hline
  Circuit Designer&675&5000&32&7.79s&243.5ms\\ \hline
  Worked For IBM&260&5000&40&6.8s&170.1ms\\ \hline
  Fission Degree&260&5000&6&1.72s&653.8ms\\ \hline
  Analog Degree&24&5000&12&3.94s&328.6ms\\ \hline
  Embedded&55&5000&30&5.1s&170.1ms\\ \hline
  Floor- \newline planning&49&5000&18&4.6s&155.2ms\\ \hline
  Circuit Designer&1401&10000&31&13.0s&419.7ms\\ \hline
  \hline\hline
  Minimum&24&5000&6&1.72s&155.2ms\\ \hline
  Maximum&2684&10000&40&13.0s&1.02s\\ \hline
  Average&785&550&20.5&6.0s&427.2ms\\ \hline
  \end{tabular}
  \label{table:node-perf}
  \caption{Node Detail Generation Time}
\end{table}

In table \ref{table:node-perf}, the node detail generation performance is shown
for the same 10 cases run previously.  This is broken out seperately because the
assumption is that when ProGENitor is deployed the career map would be initially
presented in the user interface and the details about each node would be
displayed upon user request.  Looking at table \ref{table:node-perf} shows that
this would be done because if all the data were returned at once, it could
potentially add 13 seconds to the overall run time.  This would be too slow and
unecessary for the end user.  By making each node call seperate, the average
return time on the node information would be about half a second prior to
rendering the data.  This would make the data much more user friendly.