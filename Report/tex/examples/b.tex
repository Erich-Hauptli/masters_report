\section{design b}
\label{sect:design-b}
design b description.   

\subsection{A}
Subsection A Description.  

\section{Modifications to Programmable MBIST}
\label{sect:bg-modifications}
Text

\subsection{Address Generator Expansion}
More Text and 2\textsuperscript{\textit{i}} CMs output.  Table \ref{tab:ac}
provides an example of the address complement design and Table \ref{tab:gc} shows the same for the Gray code design.  In these tables, \textit{A\textsubscript{3:0}} is the next address and \textit{C\textsubscript{3:0}} is the current output of the linear counter.

\begin{table}[H]
  \centering
  \caption[Address Complement CM Algorithm]{Address Complement Algorithm for 4-bit Address Lines}
  \begin{tabular}{|l|l|}
    \hline
    \multicolumn{2}{|c|}{Address Complement} \\
    \hline  
    Up  & Down  \\                                                          
    \hline
    A\textsubscript{3} = C\textsubscript{0}                           & A\textsubscript{3} = $\overline{C\textsubscript{0}}$              \\ %ac3
    A\textsubscript{2} = C\textsubscript{3} $\oplus$ C\textsubscript{0} & A\textsubscript{2} = C\textsubscript{3} $\oplus$ C\textsubscript{0} \\ %ac2
    A\textsubscript{1} = C\textsubscript{2} $\oplus$ C\textsubscript{0} & A\textsubscript{1} = C\textsubscript{2} $\oplus$ C\textsubscript{0} \\ %ac1
    A\textsubscript{0} = C\textsubscript{1} $\oplus$ C\textsubscript{0} & A\textsubscript{0} = C\textsubscript{1} $\oplus$ C\textsubscript{0} \\ %ac0
    \hline
  \end{tabular} 
  \label{tab:ac}
\end{table}

\begin{table}[H]
  \centering
  \caption[Gray Code CM Algorithm]{Gray Code Algorithm for 4-bit Address Lines}
  \begin{tabular}{|l|l|}
    \hline
    \multicolumn{2}{|c|}{Gray Coding} \\
    \hline  
    Up & Down \\
    \hline
    A\textsubscript{3} = C\textsubscript{3}                           & A\textsubscript{3} = $\overline{C\textsubscript{3}}$              \\ %gc3
    A\textsubscript{2} = C\textsubscript{3} $\oplus$ C\textsubscript{2} & A\textsubscript{2} = C\textsubscript{3} $\oplus$ C\textsubscript{2} \\ %gc2
    A\textsubscript{1} = C\textsubscript{2} $\oplus$ C\textsubscript{1} & A\textsubscript{1} = C\textsubscript{2} $\oplus$ C\textsubscript{1} \\ %gc1
    A\textsubscript{0} = C\textsubscript{1} $\oplus$ C\textsubscript{0} & A\textsubscript{0} = C\textsubscript{1} $\oplus$ C\textsubscript{0} \\ %gc0
    \hline  
  \end{tabular}
  \label{tab:gc}
\end{table} 

The 2\textsuperscript{\textit{i}} CM. For \textit{N} lines, the regular
2\textsuperscript{\textit{i}} requires \textit{2}x\textit{N}x\textit{N}=\textit{2N}\textsuperscript{i} mux inputs.  This number can be reduced to \textit{2N}+(\textit{2}x\textit{2}x\textit{N})=\textit{6N} mux inputs using the minimal 2\textsuperscript{\textit{i}} CM \cite{5941430}.  Table \ref{tab:2i} provides an example of the regular and minimal solution for a 4-bit address line.  In the regular solution, the address columns are rotating to the left as \textit{i} increases.  This requires a 4-input mux on each of the 4 address lines plus an additional input required for up/down address direction.  The minimal solution recognizes the C\textsubscript{0} input toggels on each count and interchanges the C\textsubscript{\textit{i}} column with the C{\textsubscript{0}} column.

\begin{table}[H]
  \caption{2\textsuperscript{\textit{i}} Addressing Example}
  \centering
  \begin{tabular}{|c||c|c|c|c||c|c|c|c|}
  \hline
    \multicolumn{1}{|c||}{} & 
    \multicolumn{4}{|c||}{Regular 2\textsuperscript{\textit{i}}} &
    \multicolumn{4}{|c|}{Minimal 2\textsuperscript{\textit{i}}} \\
  \hline
   \textit{num.}&  0 &             1 &             2 &             3 &             0 &             1 &             2 &             3 \\
   \hline
   0 & 000\textbf{0} & 00\textbf{0}0 & 0\textbf{0}00 & \textbf{0}000 & 000\textbf{0} & 00\textbf{0}0 & 0\textbf{0}00 & \textbf{0}000 \\  
   1 & 000\textbf{1} & 00\textbf{1}0 & 0\textbf{1}00 & \textbf{1}000 & 000\textbf{1} & 00\textbf{1}0 & 0\textbf{1}00 & \textbf{1}000 \\  
   2 & 001\textbf{0} & 01\textbf{0}0 & 1\textbf{0}00 & \textbf{0}001 & 001\textbf{0} & 00\textbf{0}1 & 0\textbf{0}10 & \textbf{0}010 \\  
   3 & 001\textbf{1} & 01\textbf{1}0 & 1\textbf{1}00 & \textbf{1}001 & 001\textbf{1} & 00\textbf{1}1 & 0\textbf{1}10 & \textbf{1}010 \\  
   \hline                                                                          
   4 & 010\textbf{0} & 10\textbf{0}0 & 0\textbf{0}01 & \textbf{0}010 & 010\textbf{0} & 01\textbf{0}0 & 0\textbf{0}01 & \textbf{0}100 \\  
   5 & 010\textbf{1} & 10\textbf{1}0 & 0\textbf{1}01 & \textbf{1}010 & 010\textbf{1} & 01\textbf{1}0 & 0\textbf{1}01 & \textbf{1}100 \\  
   6 & 011\textbf{0} & 11\textbf{0}0 & 1\textbf{0}01 & \textbf{0}011 & 011\textbf{0} & 01\textbf{0}1 & 0\textbf{0}11 & \textbf{0}110 \\  
   7 & 011\textbf{1} & 11\textbf{1}0 & 1\textbf{1}01 & \textbf{1}011 & 011\textbf{1} & 01\textbf{1}1 & 0\textbf{1}11 & \textbf{1}110 \\  
   \hline                                                                          
   8 & 100\textbf{0} & 00\textbf{0}1 & 0\textbf{0}10 & \textbf{0}100 & 100\textbf{0} & 10\textbf{0}0 & 1\textbf{0}00 & \textbf{0}001 \\  
   9 & 100\textbf{1} & 00\textbf{1}1 & 0\textbf{1}10 & \textbf{1}100 & 100\textbf{1} & 10\textbf{1}0 & 1\textbf{1}00 & \textbf{1}001 \\  
  10 & 101\textbf{0} & 01\textbf{0}1 & 1\textbf{0}10 & \textbf{0}101 & 101\textbf{0} & 10\textbf{0}1 & 1\textbf{0}10 & \textbf{0}011 \\  
  11 & 101\textbf{1} & 01\textbf{1}1 & 1\textbf{1}10 & \textbf{1}101 & 101\textbf{1} & 10\textbf{1}1 & 1\textbf{1}10 & \textbf{1}011 \\  
  \hline                                                                           
  12 & 110\textbf{0} & 10\textbf{0}1 & 0\textbf{0}11 & \textbf{0}110 & 110\textbf{0} & 11\textbf{0}0 & 1\textbf{0}01 & \textbf{0}101 \\  
  13 & 110\textbf{1} & 10\textbf{1}1 & 0\textbf{1}11 & \textbf{1}110 & 110\textbf{1} & 11\textbf{1}0 & 1\textbf{1}01 & \textbf{1}101 \\  
  14 & 111\textbf{0} & 11\textbf{0}1 & 1\textbf{0}11 & \textbf{0}111 & 111\textbf{0} & 11\textbf{0}1 & 1\textbf{0}11 & \textbf{0}111 \\  
  15 & 111\textbf{1} & 11\textbf{1}1 & 1\textbf{1}11 & \textbf{1}111 & 111\textbf{1} & 11\textbf{1}1 & 1\textbf{1}11 & \textbf{1}111 \\  
  \hline
  \end{tabular}
  \label{tab:2i}
\end{table}

\section{Area Comparisons}
requires 0.6\% more area.

\label{sect:cln-area}
\subsection{Address Generator Area}
Table \ref{table:ac_area_compare} below shows the area increases by  59.3\% for the address counter block and 17.7\% for the overall PMBIST area.  

\begin{table}[H]
\caption[Address Counter Area Comparison]{Address Counter Area Comparison(\textit{um\textsuperscript{2}})}
\centering
\begin{tabular}{| l | l | l | l |}
\hline
Component & Base Design & Proposed Design & Percentage Difference \\ [0.5ex]
\hline\hline
address counter & 1810   & 2884   & 59.3\% \\
pmbist area     & 6057   & 7132   & 17.7\% \\ 
\hline
\end{tabular}
\label{table:ac_area_compare}
\end{table}

It is also important to note Table \ref{table:ac_area_overhead} shows considered.   

\begin{table}[H]
\caption{Address Counter Area within Memory Block}
\centering
\begin{tabular}{p{0.5in} p{1.25in} | l | l | l |  }
\cline{3-5}
& & \multicolumn{3}{ c| }{Area Overhead Percentages} \\
\hline
\multicolumn{1}{|p{0.5in}|}{Memory Size} & Total Memory Area (\textit{um\textsuperscript{2}}) & Base Design & Proposed Design & Difference \\ [1ex]
\hline\hline
\multicolumn{1}{|c|}{64x8  }  & 15780  & 27.7\% & 31.1\% & 3.4\% \\
\multicolumn{1}{|c|}{128x8 }  & 16884  & 26.4\% & 29.7\% & 3.3\% \\
\multicolumn{1}{|c|}{256x8 }  & 19333  & 23.9\% & 26.9\% & 3.1\% \\
\multicolumn{1}{|c|}{512x8 }  & 24108  & 20.1\% & 22.8\% & 2.7\% \\
\multicolumn{1}{|c|}{1024x8}  & 34013  & 15.1\% & 17.3\% & 2.2\% \\
\multicolumn{1}{|c|}{2048x8}  & 53276  & 10.2\% & 11.8\% & 1.6\% \\ 
\multicolumn{1}{|c|}{4096x8}  & 92093  & 6.2\%  & 7.2\%  & 1.0\% \\
\multicolumn{1}{|c|}{8192x8}  & 172577 & 3.4\%  & 4.0\%  & 0.6\% \\ [1ex]
\hline
\end{tabular}
\label{table:ac_area_overhead}
\end{table}


\subsection{Pattern Generator Area}
Table \ref{tab:pg_memory_compare} auxiliary memory.

\begin{table}[H]
\caption{Area of Pattern Generator Compared to Auxiliary Memory}
\centering
\begin{tabular}{|c| c| c|}
\hline
Memory Size & Memory Area & Area Reduction \\ [0.5ex]
\hline\hline
4x8   & 10289 & 78.6\%  \\
8x8   & 11393 & 80.6\%  \\
16x8  & 12497 & 82.4\%  \\
32x8  & 13601 & 83.8\%  \\
64x8  & 14706 & 85.0\%  \\
128x8 & 15809 & 86.0\%  \\
256x8 & 18258 & 87.9\%  \\
512x8 & 23033 & 90.4\%  \\
\hline
\end{tabular}
\label{tab:pg_memory_compare}
\end{table}

\subsubsection{C}
Subsection C Description.  



% Flowcharting techniques for easy maintenance
% Author: Brent Longborough
\documentclass[x11names]{article}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,chains}
\begin{document}
% =================================================
% Set up a few colours
\colorlet{lcfree}{Green3}
\colorlet{lcnorm}{Blue3}
\colorlet{lccong}{Red3}
% -------------------------------------------------
% Set up a new layer for the debugging marks, and make sure it is on
% top
\pgfdeclarelayer{marx}
\pgfsetlayers{main,marx}
% A macro for marking coordinates (specific to the coordinate naming
% scheme used here). Swap the following 2 definitions to deactivate
% marks.
\providecommand{\cmark}[2][]{%
  \begin{pgfonlayer}{marx}
    \node [nmark] at (c#2#1) {#2};
  \end{pgfonlayer}{marx}
  } 
\providecommand{\cmark}[2][]{\relax} 
% -------------------------------------------------
% Start the picture
\begin{tikzpicture}[%
    >=triangle 60,              % Nice arrows; your taste may be different
    start chain=going below,    % General flow is top-to-bottom
    node distance=6mm and 60mm, % Global setup of box spacing
    every join/.style={norm},   % Default linetype for connecting boxes
    ]
% ------------------------------------------------- 
% A few box styles 
% <on chain> *and* <on grid> reduce the need for manual relative
% positioning of nodes
\tikzset{
  base/.style={draw, on chain, on grid, align=center, minimum height=4ex},
  proc/.style={base, rectangle, text width=8em},
  test/.style={base, diamond, aspect=2, text width=5em},
  term/.style={proc, rounded corners},
  % coord node style is used for placing corners of connecting lines
  coord/.style={coordinate, on chain, on grid, node distance=6mm and 25mm},
  % nmark node style is used for coordinate debugging marks
  nmark/.style={draw, cyan, circle, font={\sffamily\bfseries}},
  % -------------------------------------------------
  % Connector line styles for different parts of the diagram
  norm/.style={->, draw, lcnorm},
  free/.style={->, draw, lcfree},
  cong/.style={->, draw, lccong},
  it/.style={font={\small\itshape}}
}
% -------------------------------------------------
% Start by placing the nodes
\node [proc, densely dotted, it] (p0) {New trigger message thread};
% Use join to connect a node to the previous one 
\node [term, join]      {Trigger scheduler};
\node [proc, join] (p1) {Get quota $k > 1$};
\node [proc, join]      {Open queue};
\node [proc, join]      {Dispatch message};
\node [test, join] (t1) {Got msg?};
% No join for exits from test nodes - connections have more complex
% requirements
% We continue until all the blocks are positioned
\node [proc] (p2) {$k \mathbin{{-}{=}} 1$};
\node [proc, join] (p3) {Dispatch message};
\node [test, join] (t2) {Got msg?};
\node [test] (t3) {Capacity?};
\node [test] (t4) {$k \mathbin{{-}{=}} 1$};
% We position the next block explicitly as the first block in the
% second column.  The chain 'comes along with us'. The distance
% between columns has already been defined, so we don't need to
% specify it.
\node [proc, fill=lcfree!25, right=of p1] (p4) {Reset congestion};
\node [proc, join=by free] {Set \textsc{mq} wait flag};
\node [proc, join=by free] (p5) {Dispatch message};
\node [test, join=by free] (t5) {Got msg?};
\node [test] (t6) {Capacity?};
% Some more nodes specifically positioned (we could have avoided this,
% but try it and you'll see the result is ugly).
\node [test] (t7) [right=of t2] {$k \mathbin{{-}{=}} 1$};
\node [proc, fill=lccong!25, right=of t3] (p8) {Set congestion};
\node [proc, join=by cong, right=of t4] (p9) {Close queue};
\node [term, join] (p10) {Exit trigger message thread};
% -------------------------------------------------
% Now we place the coordinate nodes for the connectors with angles, or
% with annotations. We also mark them for debugging.
\node [coord, right=of t1] (c1)  {}; \cmark{1}   
\node [coord, right=of t3] (c3)  {}; \cmark{3}   
\node [coord, right=of t6] (c6)  {}; \cmark{6}   
\node [coord, right=of t7] (c7)  {}; \cmark{7}   
\node [coord, left=of t4]  (c4)  {}; \cmark{4}   
\node [coord, right=of t4] (c4r) {}; \cmark[r]{4}
\node [coord, left=of t7]  (c5)  {}; \cmark{5}   
% -------------------------------------------------
% A couple of boxes have annotations
\node [above=0mm of p4, it] {(Queue was empty)};
\node [above=0mm of p8, it] {(Queue was not empty)};
% -------------------------------------------------
% All the other connections come out of tests and need annotating
% First, the straight north-south connections. In each case, we first
% draw a path with a (consistently positioned) annotation node, then
% we draw the arrow itself.
\path (t1.south) to node [near start, xshift=1em] {$y$} (p2);
  \draw [*->,lcnorm] (t1.south) -- (p2);
\path (t2.south) to node [near start, xshift=1em] {$y$} (t3); 
  \draw [*->,lcnorm] (t2.south) -- (t3);
\path (t3.south) to node [near start, xshift=1em] {$y$} (t4); 
  \draw [*->,lcnorm] (t3.south) -- (t4);
\path (t5.south) to node [near start, xshift=1em] {$y$} (t6); 
  \draw [*->,lcfree] (t5.south) -- (t6);
\path (t6.south) to node [near start, xshift=1em] {$y$} (t7); 
  \draw [*->,lcfree] (t6.south) -- (t7); 
% ------------------------------------------------- 
% Now the straight east-west connections. To provide consistent
% positioning of the test exit annotations, we have positioned
% coordinates for the vertical part of the connectors. The annotation
% text is positioned on a path to the coordinate, and then the whole
% connector is drawn to its destination box.
\path (t3.east) to node [near start, yshift=1em] {$n$} (c3); 
  \draw [o->,lccong] (t3.east) -- (p8);
\path (t4.east) to node [yshift=-1em] {$k \leq 0$} (c4r); 
  \draw [o->,lcnorm] (t4.east) -- (p9);
% -------------------------------------------------
% Finally, the twisty connectors. Again, we place the annotation
% first, then draw the connector
\path (t1.east) to node [near start, yshift=1em] {$n$} (c1); 
  \draw [o->,lcfree] (t1.east) -- (c1) |- (p4);
\path (t2.east) -| node [very near start, yshift=1em] {$n$} (c1); 
  \draw [o->,lcfree] (t2.east) -| (c1);
\path (t4.west) to node [yshift=-1em] {$k>0$} (c4); 
  \draw [*->,lcnorm] (t4.west) -- (c4) |- (p3);
\path (t5.east) -| node [very near start, yshift=1em] {$n$} (c6); 
  \draw [o->,lcfree] (t5.east) -| (c6); 
\path (t6.east) to node [near start, yshift=1em] {$n$} (c6); 
  \draw [o->,lcfree] (t6.east) -| (c7); 
\path (t7.east) to node [yshift=-1em] {$k \leq 0$} (c7); 
  \draw [o->,lcfree] (t7.east) -- (c7)  |- (p9);
\path (t7.west) to node [yshift=-1em] {$k>0$} (c5); 
  \draw [*->,lcfree] (t7.west) -- (c5) |- (p5);
% -------------------------------------------------
% A last flourish which breaks all the rules
\draw [->,MediumPurple4, dotted, thick, shorten >=1mm]
  (p9.south) -- ++(5mm,-3mm)  -- ++(27mm,0) 
  |- node [black, near end, yshift=0.75em, it]
    {(When message + resources available)} (p0);
% -------------------------------------------------
\end{tikzpicture}
% =================================================
\end{document}


